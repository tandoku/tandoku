namespace Tandoku.Content.Transforms;

using System;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.IO.Abstractions;
using CsvHelper;
using CsvHelper.Configuration;

public sealed class ImportMediaTransform : ContentBlockRewriter
{
    private readonly IFileSystem fileSystem;
    private readonly MediaCollection mediaCollection;
    private readonly IDirectoryInfo mediaDir;
    private readonly string? imagePrefix;
    private readonly string? audioPrefix;

    private KeyValuePair<string, Dictionary<MediaKey, MediaRecord>> currentFileMedia;

    public ImportMediaTransform(
        string mediaPath,
        string? imagePrefix,
        string? audioPrefix,
        MediaCollection mediaCollection,
        IFileSystem? fileSystem = null)
    {
        this.fileSystem = fileSystem ?? new FileSystem();
        this.mediaDir = this.fileSystem.GetDirectory(mediaPath);
        this.imagePrefix = imagePrefix;
        this.audioPrefix = audioPrefix;
        this.mediaCollection = mediaCollection;
    }

    public override ContentBlock? Visit(TextBlock block)
    {
        if (block.Source?.Ordinal is not null)
        {
            block = this.ImportMedia(
                block,
                new MediaKey(null, block.Source.Ordinal.Value));
        }
        else if (block.References.FirstOrDefault() is var reference &&
            reference.Value.Source?.Ordinal is not null)
        {
            block = this.ImportMedia(
                block,
                new MediaKey(reference.Key, reference.Value.Source.Ordinal.Value));
        }
        return block;
    }

    private TextBlock ImportMedia(TextBlock block, MediaKey mediaKey)
    {
        var baseName = this.EnsureCurrentFileMedia();

        if (!this.currentFileMedia.Value.TryGetValue(mediaKey, out var record))
            return block;

        var mediaSubdir = this.mediaDir.GetSubdirectory(baseName);

        var imageFile = mediaSubdir.GetFile(record.ImageName);
        if (imageFile.Exists)
        {
            block = block with
            {
                // TODO - include content baseName in image/audio path
                Image = new ContentImage { Name = $"{this.imagePrefix}{imageFile.Name}" },
            };
            this.mediaCollection.Images.Add(imageFile.FullName);
        }

        if (mediaKey.RefName is null)
        {
            var audioFile = mediaSubdir.GetFile(record.AudioName);
            if (audioFile.Exists)
            {
                block = block with
                {
                    // TODO - include content baseName in image/audio path
                    Audio = new ContentAudio { Name = $"{this.audioPrefix}{audioFile.Name}" },
                };
                this.mediaCollection.Audio.Add(audioFile.FullName);
            }
        }

        return block;
    }

    private string EnsureCurrentFileMedia()
    {
        var baseName = this.CurrentFile?.GetBaseName() ??
            throw new InvalidOperationException();

        if (this.currentFileMedia.Key != this.CurrentFile.FullName)
        {
            if (string.IsNullOrEmpty(baseName))
                throw new InvalidOperationException($"Cannot derive base name from {this.CurrentFile}");

            var metadataFile = this.mediaDir.GetSubdirectory(baseName).GetFile($"{baseName}.tsv");
            if (!metadataFile.Exists)
                throw new InvalidOperationException($"Missing media metadata file {metadataFile}");

            var csvConfig = new CsvConfiguration(CultureInfo.InvariantCulture)
            {
                Delimiter = "\t",
                HasHeaderRecord = false,
            };
            using var streamReader = metadataFile.OpenText();
            using var csvReader = new CsvReader(streamReader, csvConfig);

            var map = new Dictionary<MediaKey, MediaRecord>();

            while (csvReader.Read())
            {
                if (csvReader.ColumnCount != 6)
                    throw new InvalidDataException($"Invalid row with {csvReader.ColumnCount} columns in {metadataFile}");

                var mediaKey = ParseMediaKeyFromText(csvReader[0]);
                var audio = ParseAudio(csvReader[2]);
                var image = ParseImage(csvReader[3]);

                var record = new MediaRecord(image, audio);

                map.Add(mediaKey, record);
            }

            this.currentFileMedia = KeyValuePair.Create(this.CurrentFile.FullName, map);

            MediaKey ParseMediaKeyFromText(string? text)
            {
                // Parse out subtitle text generated by SubtitleGenerator with purpose = MediaExtraction, either:
                // <content-name>|<ordinal>
                // OR
                // <content-name>|<ref-name>|<ordinal>

                if (!string.IsNullOrWhiteSpace(text))
                {
                    var split = text.Split('|');
                    if (split.Length > 1 &&
                        int.TryParse(split.Last(), CultureInfo.InvariantCulture, out var ordinal))
                    {
                        var refName = split.Length > 2 ? split[1] : null;
                        return new MediaKey(refName, ordinal);
                    }
                }
                throw new InvalidDataException($"Unexpected text '{text}' in {metadataFile}");
            }

            string ParseAudio(string? audio)
            {
                // Parse out audio reference (Anki format):
                // [sound:<filename>]
                return audio is not null && TryParseInfix(audio, "[sound:", "]", out var value) ?
                    value :
                    throw new InvalidDataException($"Unexpected audio '{audio}' in {metadataFile}");
            }

            string ParseImage(string? image)
            {
                // Parse out image reference (Anki format):
                // <img src='<filename>'>
                return image is not null && TryParseInfix(image, "<img src='", "'>", out var value) ?
                    value :
                    throw new InvalidDataException($"Unexpected audio '{image}' in {metadataFile}");
            }

            bool TryParseInfix(string s, string prefix, string suffix, [NotNullWhen(true)] out string? value)
            {
                if (s.StartsWith(prefix, StringComparison.Ordinal) &&
                    s.EndsWith(suffix, StringComparison.Ordinal))
                {
                    value = s.Substring(prefix.Length, s.Length - prefix.Length - suffix.Length);
                    return true;
                }
                value = null;
                return false;
            }
        }
        return baseName;
    }

    private sealed record MediaKey(string? RefName, int Ordinal);
    private sealed record MediaRecord(string ImageName, string AudioName);
}

public sealed class MediaCollection
{
    public List<string> Images { get; } = [];
    public List<string> Audio { get; } = [];
}
